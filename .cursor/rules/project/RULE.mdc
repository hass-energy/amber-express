---
description: Amber Express project context and agent behavioral rules - always applied
alwaysApply: true
---

# Amber Express Project Context

This repository contains **Amber Express** - a Python 3.13+ Home Assistant custom component for real-time Amber Electric price monitoring with smart polling and WebSocket support.

## Project overview

The integration provides real-time electricity price monitoring from Amber Electric's API, with intelligent polling that reduces API calls once confirmed prices are received.

### Core components

- **Coordinator** (`coordinator.py`): Orchestrates data fetching with smart polling logic
- **WebSocket** (`websocket.py`): Real-time price updates via WebSocket connection
- **Sensors** (`sensor.py`): Expose price and usage data to Home Assistant
- **Binary Sensors** (`binary_sensor.py`): Expose price spike and renewables status
- **Config Flow** (`config_flow.py`): UI-based configuration

### Project structure

```
custom_components/amber_express/
├── coordinator.py          # Smart polling coordinator
├── websocket.py            # WebSocket client
├── sensor.py               # Sensor entities
├── binary_sensor.py        # Binary sensor entities
├── config_flow.py          # Configuration UI
├── translations/           # i18n strings (en.json)
└── manifest.json           # Integration metadata
tests/                      # Test suite
```

## Development tools

- **Package manager**: uv (use `uv sync` for dependencies, `uv run` to execute tools)
- **Testing**: pytest
- **Linting/Formatting**: Ruff (Python), Prettier (JSON)
- **Type checking**: Pyright

## Agent behavioral rules

These rules apply to all AI agent interactions with this codebase:

### Design principles

**Convention over configuration**: Prefer uniform patterns that work the same everywhere over configurable options that require case-by-case logic.

- Derive behavior from existing structure rather than adding metadata flags
- Make all instances of a pattern work the same way - no special cases
- Let upstream validation (e.g., config flows) enforce constraints so downstream code can assume valid data

**Composition over complexity**: Build features by composing simple, focused components rather than adding conditional logic to existing code.

- Separate concerns: validation happens at config flow boundaries, processing assumes valid input
- Avoid "check if X then do Y else do Z" patterns - instead, make X and Y go through the same code path
- When adding a feature, prefer creating new simple components over adding branches to existing ones

### Clean changes

When making changes, don't leave behind comments describing what was once there.
Comments should always describe code as it exists without reference to former code.

### API evolution

When making changes, don't leave behind backwards-compatible interfaces for internal APIs.
There should always be a complete clean changeover.

### Error context

The main branch is always clean with no errors or warnings.
Any errors, warnings, or test failures you encounter are directly related to recent changes in the current branch/PR.
These issues must be fixed as part of the work - they indicate problems introduced by the changes being made.

### Property access

Always assume that accessed properties/fields which should exist do exist directly.
Rely on errors occurring if they do not when they indicate a coding error and not a possibly None value.
This is especially true in tests where you have added entities and then must access them later.
Having None checks there reduces readability and makes the test more fragile to passing unexpectedly.

### Code review guidelines

When reviewing code, rely on linting tools (Ruff and Pyright) to identify issues that they can detect.
Do not report on issues that these tools already catch, such as:

- Unused imports
- Type errors
- Style violations
- Formatting issues
- Other issues detectable by static analysis tools

Focus review comments on:

- Logic errors and bugs
- Architectural concerns
- Performance issues
- Security vulnerabilities
- Code clarity and maintainability
- Missing tests or documentation

## Universal code standards

- **Python**: 3.13+ with modern features (pattern matching, `str | None` syntax, f-strings, dataclasses)
- **Type hints**: Required on all functions, methods, and variables
- **Typing philosophy**: Type at boundaries, use TypedDict/TypeGuard for narrowing, prefer types over runtime checks
- **Formatting**: Ruff (Python), Prettier (JSON)
- **Linting**: Ruff
- **Type checking**: Pyright
- **Language**: American English for all code, comments, and documentation
- **Testing**: pytest with coverage

### Version matching

The version number must be consistent across:

- `pyproject.toml` (`version = "x.y.z"`)
- `custom_components/amber_express/manifest.json` (`"version": "x.y.z"`)

When updating version numbers, update both files together.
