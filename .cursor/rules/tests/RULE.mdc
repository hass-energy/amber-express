---
applyTo: tests/**
description: Testing standards
globs: [tests/**]
alwaysApply: false
---

# Testing standards

## Test style

Use function-style pytest tests, not class-based test organization:

```python
# ✅ Good - function style
def test_coordinator_fetches_prices() -> None:
    coordinator = create_coordinator()
    result = coordinator.fetch()
    assert result.general_price > 0


# ❌ Bad - class style
class TestCoordinator:
    def test_fetches_prices(self) -> None: ...
```

## Parametrized data-driven tests

Use parametrized tests with test data rather than many similar test functions:

```python
@pytest.mark.parametrize("price_type,expected", [
    ("general", 0.25),
    ("feed_in", -0.10),
])
def test_price_parsing(price_type: str, expected: float) -> None:
    result = parse_price(price_type)
    assert result == expected
```

## Property access in tests

Access properties directly without None checks when you have created the entities:

```python
# ✅ Good - direct access
coordinator = hass.data[DOMAIN][entry.entry_id]
assert coordinator.data.general_price == 0.25

# ❌ Bad - unnecessary None checks
coordinator = hass.data[DOMAIN].get(entry.entry_id)
if coordinator is not None:
    assert coordinator.data.general_price == 0.25
```

None checks reduce readability and make tests fragile to passing unexpectedly.

## Fixture patterns

```python
@pytest.fixture
def mock_config_entry() -> MockConfigEntry:
    """Return mocked config entry."""
    return MockConfigEntry(
        title="Test Site",
        domain=DOMAIN,
        data={CONF_API_KEY: "test_key"},
        unique_id="test_site_id",
    )


@pytest.fixture
async def init_integration(
    hass: HomeAssistant,
    mock_config_entry: MockConfigEntry,
) -> MockConfigEntry:
    """Set up integration for testing."""
    mock_config_entry.add_to_hass(hass)
    await hass.config_entries.async_setup(mock_config_entry.entry_id)
    await hass.async_block_till_done()
    return mock_config_entry
```

## Snapshot testing

Use snapshots for complex data structures and entity states:

```python
@pytest.mark.usefixtures("init_integration")
async def test_entities(
    hass: HomeAssistant,
    snapshot: SnapshotAssertion,
    entity_registry: er.EntityRegistry,
    mock_config_entry: MockConfigEntry,
) -> None:
    """Test sensor entities."""
    await snapshot_platform(hass, entity_registry, snapshot, mock_config_entry.entry_id)
```

## Config flow testing

Test both success paths and error handling:

```python
async def test_user_flow_success(hass):
    """Test successful user flow."""
    result = await hass.config_entries.flow.async_init(DOMAIN, context={"source": SOURCE_USER})
    assert result["type"] == FlowResultType.FORM

    result = await hass.config_entries.flow.async_configure(result["flow_id"], user_input={...})
    assert result["type"] == FlowResultType.CREATE_ENTRY


async def test_flow_connection_error(hass, mock_api_error):
    """Test connection error handling."""
    result = await hass.config_entries.flow.async_init(DOMAIN, context={"source": SOURCE_USER})
    result = await hass.config_entries.flow.async_configure(result["flow_id"], user_input={...})
    assert result["errors"] == {"base": "cannot_connect"}
```
